#include  <volume_io/internal_volume_io.h>
#include  <volume_io/volume.h>
#include  <minc.h>

#include <limits.h>
#include <float.h>

#include "niftilib/nifti1_io.h"
#include "niftilib/nifti1_local.h"
#include "niftilib/analyze75.h"


/*--------------------------------------------------------------------------*/
/* Given a datatype code, set number of bytes per voxel and the swapsize.
   The swapsize is set to 0 if this datatype doesn't ever need swapping.
----------------------------------------------------------------------------*/

void
nifti_datatype_sizes(int datatype, int *nbyper, int *swapsize)
{
        int nb = 0, ss = 0;

        switch (datatype) {
        case DT_INT8:
        case DT_UINT8:
                nb =  1; ss =  0;
                break;
        case DT_INT16:
        case DT_UINT16:
                nb =  2; ss =  2;
                break;
        case DT_RGB24:
                nb =  3; ss =  0;
                break;
        case DT_INT32:
        case DT_UINT32:
        case DT_FLOAT32:
                nb =  4; ss =  4;
                break;
        case DT_COMPLEX64:
                nb =  8; ss =  4;
                break;
        case DT_FLOAT64:
        case DT_INT64:
        case DT_UINT64:
                nb =  8; ss =  8;
                break;
        case DT_FLOAT128:
                nb = 16; ss = 16;
                break;
        case DT_COMPLEX128:
                nb = 16; ss =  8;
                break;
        case DT_COMPLEX256:
                nb = 32; ss = 16;
                break;
        }

        ASSIF(nbyper, nb);
        ASSIF(swapsize, ss);
        return;
}

/*---------------------------------------------------------------------------*/
/* Given the quaternion parameters (etc.), compute a transformation matrix.
   See comments in nifti1.h for details.
     - qb,qc,qd = quaternion parameters
     - qx,qy,qz = offset parameters
     - dx,dy,dz = grid stepsizes (non-negative inputs are set to 1.0)
     - qfac     = sign of dz step (< 0 is negative; >= 0 is positive)
   If qx=qy=qz=0, dx=dy=dz=1, then the output is a rotation matrix.
   For qfac >= 0, the rotation is proper.
   For qfac <  0, the rotation is improper.
-----------------------------------------------------------------------------*/

mat44
quatern_to_mat44(float qb, float qc, float qd,
                 float qx, float qy, float qz,
                 float dx, float dy, float dz, float qfac)
{
        mat44 R;
        double a, b = qb, c = qc, d = qd, xd, yd, zd;

        /* last row is always [ 0 0 0 1 ] */

        R.m[3][0] = R.m[3][1] = R.m[3][2] = 0.0; R.m[3][3] = 1.0;

        /* compute a parameter from b,c,d */

        a = 1.0l - (b*b + c*c + d*d);
        if (a < 1.e-7l) {                    /* special case */
                a = 1.0l / sqrt(b*b + c*c + d*d);
                b *= a; c *= a; d *= a;      /* normalize (b,c,d) vector */
                a = 0.0l;                    /* a = 0 ==> 180 degree rotation */
        } else{
                a = sqrt(a);                 /* angle = 2*arccos(a) */
        }

        /* load rotation matrix, including scaling factors for voxel sizes */

        xd = (dx > 0.0) ? dx : 1.0l;         /* make sure are positive */
        yd = (dy > 0.0) ? dy : 1.0l;
        zd = (dz > 0.0) ? dz : 1.0l;

        if (qfac < 0.0)
                zd = -zd;                    /* left handedness? */

        R.m[0][0] =        (a*a + b*b - c*c - d*d) * xd;
        R.m[0][1] = 2.0l * (b*c - a*d            ) * yd;
        R.m[0][2] = 2.0l * (b*d + a*c            ) * zd;
        R.m[1][0] = 2.0l * (b*c + a*d            ) * xd;
        R.m[1][1] =        (a*a + c*c - b*b - d*d) * yd;
        R.m[1][2] = 2.0l * (c*d - a*b            ) * zd;
        R.m[2][0] = 2.0l * (b*d - a*c            ) * xd;
        R.m[2][1] = 2.0l * (c*d + a*b            ) * yd;
        R.m[2][2] =        (a*a + d*d - c*c - b*b) * zd;

        /* load offsets */

        R.m[0][3] = qx;
        R.m[1][3] = qy;
        R.m[2][3] = qz;

        return R;
}

/*---------------------------------------------------------------------------*/
/* Compute the inverse of a bordered 4x4 matrix.
   Some numerical code fragments were generated by Maple 8.
   If a singular matrix is input, the output matrix will be all zero.
   You can check for this by examining the [3][3] element, which will
   be 1.0 for the normal case and 0.0 for the bad case.
-----------------------------------------------------------------------------*/

mat44
mat44_inverse(mat44 R)
{
        double r11, r12, r13, r21, r22, r23, r31, r32, r33;
        double v1, v2, v3, deti;
        mat44 Q;
                                                           /* INPUT MATRIX:  */
        r11 = R.m[0][0]; r12 = R.m[0][1]; r13 = R.m[0][2]; /*[r11 r12 r13 v1]*/
        r21 = R.m[1][0]; r22 = R.m[1][1]; r23 = R.m[1][2]; /*[r21 r22 r23 v2]*/
        r31 = R.m[2][0]; r32 = R.m[2][1]; r33 = R.m[2][2]; /*[r31 r32 r33 v3]*/
        v1  = R.m[0][3]; v2  = R.m[1][3]; v3  = R.m[2][3]; /*[ 0   0   0   1]*/

        deti = r11*r22*r33 - r11*r32*r23 - r21*r12*r33 +
               r21*r32*r13 + r31*r12*r23 - r31*r22*r13;

        if (deti != 0.0l)
           deti = 1.0l / deti;

        Q.m[0][0] = deti * ( r22*r33 - r32*r23);
        Q.m[0][1] = deti * (-r12*r33 + r32*r13);
        Q.m[0][2] = deti * ( r12*r23 - r22*r13);
        Q.m[0][3] = deti * (-r12*r23*v3 + r12*v2*r33 + r22*r13*v3 -
                             r22*v1*r33 - r32*r13*v2 + r32*v1*r23);

        Q.m[1][0] = deti * (-r21*r33 + r31*r23);
        Q.m[1][1] = deti * ( r11*r33 - r31*r13);
        Q.m[1][2] = deti * (-r11*r23 + r21*r13);
        Q.m[1][3] = deti * ( r11*r23*v3 - r11*v2*r33 - r21*r13*v3 +
                             r21*v1*r33 + r31*r13*v2 - r31*v1*r23);

        Q.m[2][0] = deti * ( r21*r32 - r31*r22);
        Q.m[2][1] = deti * (-r11*r32 + r31*r12);
        Q.m[2][2] = deti * ( r11*r22 - r21*r12);
        Q.m[2][3] = deti * (-r11*r22*v3 + r11*r32*v2 + r21*r12*v3 -
                             r21*r32*v1 - r31*r12*v2 + r31*r22*v1);

        Q.m[3][0] = Q.m[3][1] = Q.m[3][2] = 0.0l;
        Q.m[3][3] = (deti == 0.0l) ? 0.0l : 1.0l ; /* failure if deti = 0 */

        return Q;
}

/*---------------------------------------------------------------------------*/
/* Routines to swap byte arrays in various ways:
    -  2 at a time:  ab               -> ba               [short]
    -  4 at a time:  abcd             -> dcba             [int, float]
    -  8 at a time:  abcdDCBA         -> ABCDdcba         [long long, double]
    - 16 at a time:  abcdefghHGFEDCBA -> ABCDEFGHhgfedcba [long double]
-----------------------------------------------------------------------------*/

typedef struct { unsigned char a, b; } twobytes;

void
swap_2bytes(int n, void *ar)    /* 2 bytes at a time */
{
        register int ii;
        register twobytes *tb = (twobytes *) ar;
        register unsigned char tt;

        for (ii = 0; ii < n; ii++) {
                tt = tb[ii].a; tb[ii].a = tb[ii].b; tb[ii].b = tt;
        }
        return;
}

/*---------------------------------------------------------------------------*/

typedef struct { unsigned char a, b, c, d; } fourbytes;

void
swap_4bytes(int n, void *ar)    /* 4 bytes at a time */
{
        register int ii;
        register fourbytes *tb = (fourbytes *) ar;
        register unsigned char tt;

        for (ii = 0; ii < n; ii++) {
                tt = tb[ii].a; tb[ii].a = tb[ii].d; tb[ii].d = tt;
                tt = tb[ii].b; tb[ii].b = tb[ii].c; tb[ii].c = tt;
        }
        return;
}

/*---------------------------------------------------------------------------*/

typedef struct { unsigned char a, b, c, d, D, C, B, A; } eightbytes;

void
swap_8bytes(int n, void *ar)    /* 8 bytes at a time */
{
        register int ii;
        register eightbytes *tb = (eightbytes *) ar;
        register unsigned char tt;

        for (ii = 0; ii < n; ii++) {
                tt = tb[ii].a; tb[ii].a = tb[ii].A; tb[ii].A = tt;
                tt = tb[ii].b; tb[ii].b = tb[ii].B; tb[ii].B = tt;
                tt = tb[ii].c; tb[ii].c = tb[ii].C; tb[ii].C = tt;
                tt = tb[ii].d; tb[ii].d = tb[ii].D; tb[ii].D = tt;
        }
        return;
}

/*---------------------------------------------------------------------------*/

typedef struct { unsigned char a, b, c, d, e, f, g, h,
                               H, G, F, E, D, C, B, A; } sixteenbytes;

void
swap_16bytes(int n, void *ar)    /* 16 bytes at a time */
{
        register int ii;
        register sixteenbytes *tb = (sixteenbytes *) ar;
        register unsigned char tt;

        for (ii = 0; ii < n; ii++) {
                tt = tb[ii].a; tb[ii].a = tb[ii].A; tb[ii].A = tt;
                tt = tb[ii].b; tb[ii].b = tb[ii].B; tb[ii].B = tt;
                tt = tb[ii].c; tb[ii].c = tb[ii].C; tb[ii].C = tt;
                tt = tb[ii].d; tb[ii].d = tb[ii].D; tb[ii].D = tt;

                tt = tb[ii].e; tb[ii].e = tb[ii].E; tb[ii].E = tt;
                tt = tb[ii].f; tb[ii].f = tb[ii].F; tb[ii].F = tt;
                tt = tb[ii].g; tb[ii].g = tb[ii].G; tb[ii].G = tt;
                tt = tb[ii].h; tb[ii].h = tb[ii].H; tb[ii].H = tt;
        }
        return;
}

/*---------------------------------------------------------------------------*/

void
swap_Nbytes(int n, int siz, void *ar)  /* subsuming case */
{
        switch (siz) {
        case 2:
                swap_2bytes(n, ar);
                break;
        case 4:
                swap_4bytes(n, ar);
                break;
        case 8:
                swap_8bytes(n, ar);
                break;
        case 16:
                swap_16bytes(n, ar);
                break;
        }
        return;
}

/*---------------------------------------------------------------*/
/* Byte swap NIFTI-1 file header in various places and ways.
   If is_nifti is nonzero, will also swap the NIFTI-specific
   components of the header; otherwise, only the components
   common to NIFTI and ANALYZE will be swapped.
---------------------------------------------------------------- */

void
swap_nifti_header(struct nifti_1_header *h, int is_nifti)
{

#if 0                /* ANALYZE fields not used by this software */
        swap_4(h->sizeof_hdr);
        swap_4(h->extents);
        swap_2(h->session_error);
        swap_4(h->compressed);
        swap_4(h->glmax);
        swap_4(h->glmin);
#endif

        /* these are present for both ANALYZE and NIFTI */
        swap_2bytes(8, h->dim);
        swap_4bytes(8, h->pixdim);

        swap_2(h->datatype);
        swap_2(h->bitpix);

        swap_4(h->vox_offset);
        swap_4(h->cal_max);
        swap_4(h->cal_min);

        /* this stuff is NIFTI specific */

        if (is_nifti) {
          swap_2(h->qform_code); swap_2(h->sform_code);
          swap_4(h->quatern_b); swap_4(h->quatern_c); swap_4(h->quatern_d);
          swap_4(h->qoffset_x); swap_4(h->qoffset_y); swap_4(h->qoffset_z);
          swap_4(h->intent_p1); swap_4(h->intent_p2); swap_4(h->intent_p3);
          swap_4(h->scl_slope); swap_4(h->scl_inter);
          swap_4bytes(4,h->srow_x);
          swap_4bytes(4,h->srow_y);
          swap_4bytes(4,h->srow_z);
          swap_2(h->intent_code); swap_4(h->toffset);
          swap_2(h->slice_start); swap_2(h->slice_end);
          swap_4(h->slice_duration);
        }
        return;
}

#define USE_STAT
#ifdef  USE_STAT
/*---------------------------------------------------------------------------*/
/* Return the file length (0 if file not found or has no contents).
   This is a Unix-specific function, since it uses stat().
-----------------------------------------------------------------------------*/
#include <sys/types.h>
#include <sys/stat.h>

unsigned int
get_filesize(char *pathname)
{
        struct stat buf;
        int ii;

        if (pathname == NULL || *pathname == '\0')
                return 0;

        ii = stat(pathname, &buf);
        if (ii != 0)
                return 0;

        return (unsigned int) buf.st_size;
}

#else  /*---------- non-Unix version of the above, less efficient -----------*/

unsigned int
get_filesize(char *pathname)
{
        FILE *fp;
        unsigned int len;

        if (pathname == NULL || *pathname == '\0')
                return 0;
        if ( (fp = fopen(pathname, "rb")) == NULL)
                return 0;

        fseek(fp, 0L, SEEK_END);
        len = (unsigned int) ftell(fp);
        fclose(fp);

        return len;
}

#endif /* USE_STAT */

/*--------------------------------------------------------------------------*/
/* Read in a NIFTI-1 or ANALYZE-7.5 file (pair) into a nifti_image struct.
    - Input is .hdr or .nii filename.
    - Return value is NULL if something fails badly.
    - If read_data parameter is nonzero, the image data will actually
      be read in; otherwise, it will have to be read later
      (e.g., using the nifti_image_load() function).
    - The image data will be stored in whatever data format the
      input data is; no scaling will be applied.
    - DT_BINARY data is not supported!
    - nifti_image_free() can be used to delete the returned struct,
      when you are done with it.
----------------------------------------------------------------------------*/

#undef  ERREX
#define ERREX(msg)                                            \
 do { fprintf(stderr,"** ERROR: nifti_image_read(%s): %s\n",  \
              (hname != NULL) ? hname : "(null)" , (msg) ) ;  \
      return NULL; } while(0)

nifti_image *
nifti_image_read(char *hname, int read_data)
{
        struct nifti_1_header nhdr;
        nifti_image *nim;
        FILE *fp;
        int   ii, doswap, hlen, ilen, slen, ioff, ndim, nvox;
        int   is_nifti, is_onefile;
        short ss;
        char *iname = NULL, *sbuf, buf[16];

        /** check input file(s) for sanity **/

        if (hname == NULL || *hname == '\0')
                ERREX("bad filename");

        hlen = strlen(hname);
        if (hlen < 5)
                ERREX("too short filename");

        /** open input file **/
        fp = fopen(hname , "rb");
        if (fp == NULL)
                ERREX("can't open header file");

        /** test if header file starts with ASCII string "<nifti_image";
         *  if so, read the dataset that special way and return now
         *  (this is NOT part of the NIFTI-1 standard!)
         */
        ii = fread(buf, 1, 12, fp);
        if (ii < 12) {
                fclose(fp);
                ERREX("bad header read");
        }
        rewind(fp);
        buf[12] = '\0';

        if (strcmp(buf, "<nifti_image") == 0) {  /* have an ASCII header! */
                slen = get_filesize(hname);
                if (slen > 65530)
                        slen = 65530;
                sbuf = (char *) calloc(sizeof(char), slen+1);
                fread(sbuf, 1, slen, fp);
                fclose(fp);

                nim = nifti_image_from_ascii(sbuf);
                free(sbuf);

                if (nim == NULL)
                        ERREX("bad ASCII header read");

                nim->nifti_type = 3;
                nim->iname_offset = -1;

                if (read_data) nifti_image_load(nim);
                else           nim->data = NULL;

                return nim;
        }

        /***** Normal case:  read binary header *****/
        ii = fread(&nhdr, 1, sizeof(nhdr), fp);          /* read it */
        fclose(fp);                                      /* close the file */

        if (ii < sizeof(nhdr))
                ERREX("bad binary header read");

        /** check if have to swap bytes **/
        doswap = 0;                                      /* swap data flag */
        ss = nhdr.dim[0];
        if (ss != 0) {   /* check dim[0] for good value */
                if (ss < 0 || ss > 7) {
                        swap_2(ss);
                        if (ss < 0 || ss > 7)
                                ERREX("bad dim[0]");
                        doswap = 1;
                }
        } else {    /* dim[0] == 0 is illegal, but does occur */
                ii = nhdr.sizeof_hdr;   /* so check sizeof_hdr field instead */
                if (ii != sizeof(nhdr)) {
                        swap_4(ii);
                        if (ii != sizeof(nhdr))
                                ERREX("bad sizeof_hdr");
                        doswap = 1;
                }
        }

        /** determine if this is a NIFTI-1 compliant header **/
        is_nifti = NIFTI_VERSION(nhdr);
        if (doswap)
                swap_nifti_header(&nhdr, is_nifti);

        if (nhdr.datatype == DT_BINARY || nhdr.datatype == DT_UNKNOWN)
                ERREX("bad datatype");

        if (nhdr.dim[1] <= 0)
                ERREX("bad dim[1]");

        for (ii = 2; ii <= 7; ii++) {
                if (nhdr.dim[ii] <= 0)
                        nhdr.dim[ii] = 1;  /* fix bad dim[] values */
        }

        /** get number of dimensions (ignoring dim[0] now) **/

        for (ii = 7; ii >= 2; ii--) {           /* loop backwards until we  */
                if (nhdr.dim[ii] > 1)           /* find a dim bigger than 1 */
                        break;
        }
        ndim = ii;

        /* set bad grid spacings to 1.0 */
        for (ii = 1; ii <= 7; ii++) {
                if (nhdr.pixdim[ii] == 0.0 || !IS_GOOD_FLOAT(nhdr.pixdim[ii]))
                        nhdr.pixdim[ii] = 1.0;
        }

        /** read image data from file 'iname' starting at offset 'ioff' **/
        is_onefile = is_nifti && NIFTI_ONEFILE(nhdr);

        if (is_onefile) {
                ioff = (int) nhdr.vox_offset;
                if (ioff < sizeof(nhdr))
                        ioff = sizeof(nhdr);
        } else {
                ioff = 0;
        }

        iname = strdup(hname);
        if (!is_onefile)
                strcpy(iname + hlen - 4, ".img") ; /* create .img filename */

        ilen = get_filesize(iname);          /* find size of image data file */

        if (ilen <= ioff) {
                free(iname);
                ERREX("bad data file");
        }

        /*=== create output image struct and start to set it up ===*/
        nim = (nifti_image *) calloc(1, sizeof(nifti_image));

        if (is_nifti) nim->nifti_type = (is_onefile) ? 1 : 2;
        else          nim->nifti_type = 0;

        ii = short_order();
        if (doswap)   nim->byteorder = REVERSE_ORDER(ii);
        else          nim->byteorder = ii;

        /** dimensions of data array **/
        nim->ndim = nim->dim[0] = ndim;
        nim->nx   = nim->dim[1] = nhdr.dim[1]; nvox  = nim->nx;
        nim->ny   = nim->dim[2] = nhdr.dim[2]; nvox *= nim->ny;
        nim->nz   = nim->dim[3] = nhdr.dim[3]; nvox *= nim->nz;
        nim->nt   = nim->dim[4] = nhdr.dim[4]; nvox *= nim->nt;
        nim->nu   = nim->dim[5] = nhdr.dim[5]; nvox *= nim->nu;
        nim->nv   = nim->dim[6] = nhdr.dim[6]; nvox *= nim->nv;
        nim->nw   = nim->dim[7] = nhdr.dim[7]; nvox *= nim->nw;
        nim->nvox = nvox;

        /** type of data in voxels and how many bytes per voxel */

        nim->datatype = nhdr.datatype;

        nifti_datatype_sizes(nim->datatype, &(nim->nbyper), &(nim->swapsize));
        if (nim->nbyper == 0) {
                free(nim);
                free(iname);
                ERREX("bad datatype");
        }

        /** grid spacings **/
        nim->dx = nim->pixdim[1] = nhdr.pixdim[1];
        nim->dy = nim->pixdim[2] = nhdr.pixdim[2];
        nim->dz = nim->pixdim[3] = nhdr.pixdim[3];
        nim->dt = nim->pixdim[4] = nhdr.pixdim[4];
        nim->du = nim->pixdim[5] = nhdr.pixdim[5];
        nim->dv = nim->pixdim[6] = nhdr.pixdim[6];
        nim->dw = nim->pixdim[7] = nhdr.pixdim[7];

        /** compute qto_xyz xform from pixel indices (i,j,k) to (x,y,z) **/
        if (!is_nifti || nhdr.qform_code <= 0) { /** default transformation **/
                nim->qto_xyz.m[0][0] = nim->dx;  /* grid spacings */
                nim->qto_xyz.m[1][1] = nim->dy;  /* along diagonal */
                nim->qto_xyz.m[2][2] = nim->dz;

                /* off diagonal is zero */
                nim->qto_xyz.m[0][1] = nim->qto_xyz.m[0][2]
                                     = nim->qto_xyz.m[0][3] = 0.0;
                nim->qto_xyz.m[1][0] = nim->qto_xyz.m[1][2]
                                     = nim->qto_xyz.m[1][3] = 0.0;
                nim->qto_xyz.m[2][0] = nim->qto_xyz.m[2][1]
                                     = nim->qto_xyz.m[2][3] = 0.0;

                /* last row is always [ 0 0 0 1 ] */
                nim->qto_xyz.m[3][0] = nim->qto_xyz.m[3][1]
                                     = nim->qto_xyz.m[3][2] = 0.0;
                nim->qto_xyz.m[3][3] = 1.0;

                nim->qform_code = NIFTI_XFORM_UNKNOWN;
        } else {                 /** NIFTI: quaternion-specified xformation **/
                nim->quatern_b = FIXED_FLOAT(nhdr.quatern_b);
                nim->quatern_c = FIXED_FLOAT(nhdr.quatern_c);
                nim->quatern_d = FIXED_FLOAT(nhdr.quatern_d);

                nim->qoffset_x = FIXED_FLOAT(nhdr.qoffset_x);
                nim->qoffset_y = FIXED_FLOAT(nhdr.qoffset_y);
                nim->qoffset_z = FIXED_FLOAT(nhdr.qoffset_z);

                /* left-handedness? */
                nim->qfac = (nhdr.pixdim[0] < 0.0) ? -1.0 : 1.0;

                nim->qto_xyz = quatern_to_mat44(
                               nim->quatern_b, nim->quatern_c, nim->quatern_c,
                               nim->qoffset_x, nim->qoffset_y, nim->qoffset_z,
                               nim->dx       , nim->dy       , nim->dz       ,
                               nim->qfac                                      );

                nim->qform_code = nhdr.qform_code;
        }

        /** load inverse transformation (x,y,z) -> (i,j,k) **/
        nim->qto_ijk = mat44_inverse(nim->qto_xyz);

        /** load sto_xyz affine transformation, if present **/
        if (!is_nifti || nhdr.sform_code <= 0) { /** no sto transformation **/
                nim->sform_code = NIFTI_XFORM_UNKNOWN;
        } else {    /** sto xformation from srow_*[] **/
                nim->sto_xyz.m[0][0] = nhdr.srow_x[0];
                nim->sto_xyz.m[0][1] = nhdr.srow_x[1];
                nim->sto_xyz.m[0][2] = nhdr.srow_x[2];
                nim->sto_xyz.m[0][3] = nhdr.srow_x[3];

                nim->sto_xyz.m[1][0] = nhdr.srow_y[0];
                nim->sto_xyz.m[1][1] = nhdr.srow_y[1];
                nim->sto_xyz.m[1][2] = nhdr.srow_y[2];
                nim->sto_xyz.m[1][3] = nhdr.srow_y[3];

                nim->sto_xyz.m[2][0] = nhdr.srow_z[0];
                nim->sto_xyz.m[2][1] = nhdr.srow_z[1];
                nim->sto_xyz.m[2][2] = nhdr.srow_z[2];
                nim->sto_xyz.m[2][3] = nhdr.srow_z[3];

                /* last row is always [ 0 0 0 1 ] */
                nim->sto_xyz.m[3][0] = nim->sto_xyz.m[3][1]
                                     = nim->sto_xyz.m[3][2] = 0.0;
                nim->sto_xyz.m[3][3] = 1.0;

                nim->sto_ijk = mat44_inverse(nim->sto_xyz);

                nim->sform_code = nhdr.sform_code;
        }

        /* miscellaneous NIFTI stuff */
        if (is_nifti) {
                nim->scl_slope   = FIXED_FLOAT(nhdr.scl_slope);
                nim->scl_inter   = FIXED_FLOAT(nhdr.scl_inter);

                nim->intent_code = nhdr.intent_code;

                nim->intent_p1   = FIXED_FLOAT(nhdr.intent_p1);
                nim->intent_p2   = FIXED_FLOAT(nhdr.intent_p2);
                nim->intent_p3   = FIXED_FLOAT(nhdr.intent_p3);

                nim->toffset     = FIXED_FLOAT(nhdr.toffset);

                memcpy(nim->intent_name, nhdr.intent_name, 15);
                nim->intent_name[15] = '\0';

                nim->xyz_units  = XYZT_TO_SPACE(nhdr.xyzt_units);
                nim->time_units = XYZT_TO_TIME (nhdr.xyzt_units);

                nim->freq_dim  = DIM_INFO_TO_FREQ_DIM (nhdr.dim_info);
                nim->phase_dim = DIM_INFO_TO_PHASE_DIM(nhdr.dim_info);
                nim->slice_dim = DIM_INFO_TO_SLICE_DIM(nhdr.dim_info);

                nim->slice_code     = nhdr.slice_code;
                nim->slice_start    = nhdr.slice_start;
                nim->slice_end      = nhdr.slice_end;
                nim->slice_duration = FIXED_FLOAT(nhdr.slice_duration);
        }

        /* Miscellaneous ANALYZE stuff */
        nim->cal_min = FIXED_FLOAT(nhdr.cal_min);
        nim->cal_max = FIXED_FLOAT(nhdr.cal_max);

        memcpy(nim->descrip,  nhdr.descrip,  79); nim->descrip[79]  = '\0';
        memcpy(nim->aux_file, nhdr.aux_file, 23); nim->aux_file[23] = '\0';

        /** read the data if desired, then bug out **/
        nim->fname        = strdup(hname);  /* save input filename */
        nim->iname        = iname;          /* save image filename */
        nim->iname_offset = ioff;

        if (read_data) nifti_image_load(nim);
        else           nim->data = NULL;

        return nim;
}

/*--------------------------------------------------------------------------*/
/* Load the image data from disk into an already-prepared image struct.
----------------------------------------------------------------------------*/

#undef  ERREX
#define ERREX(msg)                                               \
 do { fprintf(stderr,"** ERROR: nifti_image_load: %s\n",(msg));  \
      return; } while(0)

void
nifti_image_load(nifti_image *nim)
{
        size_t ntot, ii, ioff;
        FILE *fp;

        if (nim == NULL || nim->iname == NULL ||
            nim->nbyper <= 0 || nim->nvox <= 0)
                ERREX("bad input struct");

        /** open image data file **/

        ntot = (size_t) nim->nbyper * (size_t) nim->nvox; /* total bytes */

        fp = fopen(nim->iname, "rb");
        if (fp == NULL)
                ERREX("Can't open data file");

        if (nim->iname_offset < 0) {             /* negative offset means   */
                ii = get_filesize(nim->iname);   /* figure from end of file */
                ioff = (ii > ntot) ? ii-ntot : 0;
        } else {                              /* non-negative offset   */
                ioff = nim->iname_offset;     /* means use it directly */
        }
        fseek(fp, ioff, SEEK_SET);

        /* make space for data, then read all of it in one operation */
        if (nim->data != NULL)
                free(nim->data);

        nim->data = (void *) calloc(1, ntot);
        if (nim->data == NULL)
                ERREX("can't malloc array space");

        ii = fread(nim->data, 1, ntot, fp);             /*** data input! ***/
        fclose(fp);

        /** if read was short, fill rest of array with 0 bytes **/
        if (ii < ntot) {
                fprintf(stderr, "++ WARNING: nifti_image_load(%s):\n"
                                "   data bytes needed = %u\n"
                                "   data bytes input  = %u\n"
                                "   number missing    = %u (set to 0)\n",
                        nim->iname, (unsigned int) ntot,
                        (unsigned int) ii, (unsigned int) (ntot-ii));
                memset((char *) nim->data + ii, 0, ntot-ii);
        }

        /** byte swap array if needed **/
        if (nim->swapsize > 1 && nim->byteorder != short_order())
                swap_Nbytes(ntot / nim->swapsize, nim->swapsize, nim->data);

#ifdef isfinite
        /** check input float arrays for goodness, and fix bad numbers **/
        switch (nim->datatype) {
        case NIFTI_TYPE_FLOAT32:
        case NIFTI_TYPE_COMPLEX64:
                {
                        register float *far = (float *) nim->data;
                        register int jj, nj;

                        nj = ntot / sizeof(float);
                        for (jj = 0; jj < nj; jj++)
                                far[jj] = FIXED_FLOAT(far[jj]);
                }
                break;
        case NIFTI_TYPE_FLOAT64:
        case NIFTI_TYPE_COMPLEX128:
                {
                        register double *far = (double *) nim->data;
                        register int jj, nj;

                        nj = ntot / sizeof(double);
                        for (jj = 0; jj < nj; jj++)
                                far[jj] = FIXED_FLOAT(far[jj]);
                }
                break;
        }
#endif

        return;
}

/*--------------------------------------------------------------------------*/
/* Unload the data in a nifti_image struct, but keep the metadata.
----------------------------------------------------------------------------*/

void
nifti_image_unload(nifti_image *nim)
{
        if (nim != NULL && nim->data != NULL) {
                free(nim->data);
                nim->data = NULL;
        }
        return;
}

/*--------------------------------------------------------------------------*/
/* Free a nifti_image struct that was read by nifti_image_read().
----------------------------------------------------------------------------*/

void
nifti_image_free(nifti_image *nim)
{
   if( nim == NULL ) return ;
   if( nim->fname != NULL ) free(nim->fname) ;
   if( nim->iname != NULL ) free(nim->iname) ;
   if( nim->data  != NULL ) free(nim->data ) ;
   free(nim) ; return ;
}

/*------------------------------------------------------------------------*/
/* Un-escape a C string in place -- that is, convert XML escape sequences
   back into their characters.  (This can be done in place since the
   replacement is always smaller than the input.)  Escapes recognized are:
     -  &lt;   ->  <
     -  &gt;   ->  >
     -  &quot; ->  "
     -  &apos; ->  '
     -  &amp;  ->  &
   Also replace CR LF pair (Microsoft), or CR alone (Macintosh) with
   LF (Unix), per the XML standard.
   Return value is number of replacements made (if you care).
--------------------------------------------------------------------------*/

#undef  CR
#undef  LF
#define CR 0x0D
#define LF 0x0A

int
unescape_string(char *str)
{
        int ii, jj, nn, ll;

        if (str == NULL) return 0;  /* no string? */

        ll = strlen(str);
        if (ll == 0) return 0;

        /* scan for escapes: &something; */

        /* scan at ii; results go in at jj */
        for (ii = jj = nn = 0; ii < ll; ii++, jj++) {
                if (str[ii] == '&') {  /* start of escape? */
                        if (ii+3 < ll        &&   /* &lt; */
                            str[ii+1] == 'l' &&
                            str[ii+2] == 't' &&
                            str[ii+3] == ';'   ) {
                                str[jj] = '<';
                                ii += 3;
                                nn++;
                        } else if (ii+3 < ll        &&   /* &gt; */
                                   str[ii+1] == 'g' &&
                                   str[ii+2] == 't' &&
                                   str[ii+3] == ';'   ) {
                                str[jj] = '>';
                                ii += 3;
                                nn++;
                        } else if (ii+5 < ll        &&   /* &quot; */
                                   str[ii+1] == 'q' &&
                                   str[ii+2] == 'u' &&
                                   str[ii+3] == 'o' &&
                                   str[ii+4] == 't' &&
                                   str[ii+5] == ';'   ) {
                                str[jj] = '"';
                                ii += 5;
                                nn++;
                        } else if (ii+5 < ll        &&   /* &apos; */
                                   str[ii+1] == 'a' &&
                                   str[ii+2] == 'p' &&
                                   str[ii+3] == 'o' &&
                                   str[ii+4] == 's' &&
                                   str[ii+5] == ';'   ) {
                                str[jj] = '\'';
                                ii += 5;
                                nn++;
                        } else if (ii+4 < ll        &&  /* &amp; */
                                   str[ii+1] == 'a' &&
                                   str[ii+2] == 'm' &&
                                   str[ii+3] == 'p' &&
                                   str[ii+4] == ';'   ) {
                                str[jj] = '&';
                                ii += 4;
                                nn++;
                        } else if (ii+3 < ll        && /* look for XML style */
                                   str[ii+1] == '#' &&
                                   isdigit(str[ii+2])) {   /* &#dec; */
                                unsigned int val = '?';
                                int kk = ii + 3;

                                while (kk < ll && kk != ';') kk++;
                                sscanf(str + ii + 2, "%u", &val);
                                str[jj] = (char) val;
                                ii = kk;
                                nn++;
                        } else if (ii+4 < ll        &&
                                   str[ii+1] == '#' &&
                                   str[ii+2] == 'x' &&
                                   isxdigit(str[ii+3])) {   /* &#hex; */
                                unsigned int val = '?';
                                int kk = ii + 4;

                                while (kk < ll && kk != ';') kk++;
                                sscanf(str + ii + 3, "%x", &val);
                                str[jj] = (char) val;
                                ii = kk;
                                nn++;
                        } else if (jj < ii) {
                                /* didn't start a recognized escape*/
                                str[jj] = str[ii]; /* just copy as normal */
                        }
                } else if (str[ii] == CR) {  /* is a carriage return */
                        if (str[ii+1] == LF) { /* CR LF */
                                str[jj] = LF;
                                ii++;
                                nn++;
                        } else {               /* CR only */
                                str[jj] = LF;
                                nn++;
                        }
                } else { /* normal character, just copy to output */
                        if (jj < ii)
                                str[jj] = str[ii];
                }
                /* at this point, ii=index of last character used in scan,
                 * jj=index of last character written to (jj <= ii) */
        }

        if (jj < ll)
                str[jj] = '\0'; /* end string properly */

        return nn;
}

/*---------------------------------------------------------------------------*/

int
short_order(void)   /* determine this CPU's byte order */
{
        union {
                unsigned char bb[2];
                short ss;
        } fred;

        fred.bb[0] = 1; fred.bb[1] = 0;

        return (fred.ss == 1) ? LSB_FIRST : MSB_FIRST;
}

/*---------------------------------------------------------------------------*/

#undef  QQNUM
#undef  QNUM
#undef  QSTR

/* macro to check lhs string against "n1"; if it matches,
   interpret rhs string as a number, and put it into nim->"n2" */

#define QQNUM(n1, n2) if (strcmp(lhs, #n1) == 0) nim->n2 = strtod(rhs, NULL)

/* same, but where "n1" == "n2" */

#define QNUM(nam)    QQNUM(nam,nam)

/* macro to check lhs string against "nam"; if it matches,
   put rhs string into nim->"nam" string, with max length = "ml" */

#define QSTR(nam, ml) if (strcmp(lhs, #nam) == 0)                           \
                       strncpy(nim->nam, rhs, ml), nim->intent_name[ml] = '\0'

/*---------------------------------------------------------------------------*/
/* Take an XML-ish ASCII string and create a NIFTI image header to match.
   NULL is returned if enough information isn't present in the input string.
    - The image data can later be loaded with nifti_image_load().
    - The struct returned here can be liberated with nifti_image_free().
    - Not a lot of error checking is done here to make sure that the
      input values are reasonable!
-----------------------------------------------------------------------------*/

nifti_image *
nifti_image_from_ascii(char *str)
{
        char lhs[1024], rhs[1024];
        int ii, spos, nn, slen;
        nifti_image *nim;  /* will be output */

        if (str == NULL || *str == '\0')
                return NULL;  /* bad input!? */

        /* scan for opening string */
        spos = 0; slen = strlen(str);
        ii = sscanf(str + spos, "%1023s%n", lhs, &nn);
        spos += nn;
        if (ii == 0 || strcmp(lhs,"<nifti_image") != 0)
                return NULL;

        /* create empty image struct */
        nim = (nifti_image *) calloc(1, sizeof(nifti_image));

        nim->nx = nim->ny = nim->nz = nim->nt
                = nim->nu = nim->nv = nim->nw = 1;
        nim->dx = nim->dy = nim->dz = nim->dt
                = nim->du = nim->dv = nim->dw = nim->qfac = 1.0;

        nim->byteorder = short_order();

        /* starting at str[spos], scan for "equations" of the form
         * lhs = 'rhs' & assign rhs values into the struct component
         * named by lhs
         */
        while (1) {
                while (isspace(str[spos]))
                        spos++;  /* skip whitespace */
                if (str[spos] == '\0')
                        break;   /* end of string? */

                /* get lhs string */
                ii = sscanf(str + spos, "%1023s%n", lhs, &nn);
                spos += nn;
                if (ii == 0 || strcmp(lhs,"/>") == 0)
                        break ;  /* end of input? */

                /* skip whitespace and the '=' marker */
                while (isspace(str[spos]) || str[spos] == '=')
                        spos++;
                if (str[spos] == '\0')
                        break;  /* end of string? */

                /* if next character is a quote ', copy everything up to next '
                 * otherwise, copy everything up to next nonblank  */
                if (str[spos] == '\'') {
                        ii = spos + 1;
                        while (str[ii] != '\0' && str[ii] != '\'')
                                ii++;
                        nn = ii - spos - 1;
                        if (nn > 1023)
                                nn = 1023;
                        memcpy(rhs, str + spos + 1, nn);
                        rhs[nn] = '\0';
                        spos = (str[ii] == '\'') ? ii+1 : ii;
                } else {
                        ii = sscanf(str + spos, "%1023s%n", rhs, &nn);
                        spos += nn;
                        if (ii == 0)
                                break ;  /* nothing found? */
                }
                unescape_string(rhs);  /* remove any XML escape sequences */

                /* Now can do the assignment, based on lhs string. Start with
                 * special cases that don't fit the QNUM/QSTR macros. */
                if (strcmp(lhs, "nifti_type") == 0) {
                        if (strcmp(rhs, "ANALYZE-7.5") == 0)
                                nim->nifti_type = 0;
                        else if (strcmp(rhs, "NIFTI-1+") == 0)
                                nim->nifti_type = 1;
                        else if (strcmp(rhs, "NIFTI-1")  == 0)
                                nim->nifti_type = 2;
                        else if (strcmp(rhs, "NIFTI-1A") == 0)
                                nim->nifti_type = 3;
                } else if (strcmp(lhs, "header_filename") == 0) {
                        nim->fname = strdup(rhs);
                } else if (strcmp(lhs, "image_filename") == 0) {
                        nim->iname = strdup(rhs);
                } else if (strcmp(lhs, "sto_xyz_matrix") == 0) {
                        sscanf(rhs,
                              "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
                              &(nim->sto_xyz.m[0][0]), &(nim->sto_xyz.m[0][1]),
                              &(nim->sto_xyz.m[0][2]), &(nim->sto_xyz.m[0][3]),
                              &(nim->sto_xyz.m[1][0]), &(nim->sto_xyz.m[1][1]),
                              &(nim->sto_xyz.m[1][2]), &(nim->sto_xyz.m[1][3]),
                              &(nim->sto_xyz.m[2][0]), &(nim->sto_xyz.m[2][1]),
                              &(nim->sto_xyz.m[2][2]), &(nim->sto_xyz.m[2][3]),
                              &(nim->sto_xyz.m[3][0]), &(nim->sto_xyz.m[3][1]),
                              &(nim->sto_xyz.m[3][2]), &(nim->sto_xyz.m[3][3]));
                } else if (strcmp(lhs,"byteorder") == 0) {
                        if (strcmp(rhs, "MSB_FIRST") == 0)
                                nim->byteorder = MSB_FIRST;
                        if (strcmp(rhs, "LSB_FIRST") == 0)
                                nim->byteorder = LSB_FIRST;
                } else QQNUM(image_offset, iname_offset);
                else QNUM(datatype);
                else QNUM(ndim);
                else QNUM(nx);
                else QNUM(ny);
                else QNUM(nz);
                else QNUM(nt);
                else QNUM(nu);
                else QNUM(nv);
                else QNUM(nw);
                else QNUM(dx);
                else QNUM(dy);
                else QNUM(dz);
                else QNUM(dt);
                else QNUM(du);
                else QNUM(dv);
                else QNUM(dw);
                else QNUM(cal_min);
                else QNUM(cal_max);
                else QNUM(scl_slope);
                else QNUM(scl_inter);
                else QNUM(intent_code);
                else QNUM(intent_p1);
                else QNUM(intent_p2);
                else QNUM(intent_p3);
                else QSTR(intent_name, 15);
                else QNUM(toffset);
                else QNUM(xyz_units);
                else QNUM(time_units);
                else QSTR(descrip, 79);
                else QSTR(aux_file, 23);
                else QNUM(qform_code);
                else QNUM(quatern_b);
                else QNUM(quatern_c);
                else QNUM(quatern_d);
                else QNUM(qoffset_x);
                else QNUM(qoffset_y);
                else QNUM(qoffset_z);
                else QNUM(qfac);
                else QNUM(sform_code);
                else QNUM(freq_dim);
                else QNUM(phase_dim);
                else QNUM(slice_dim);
                else QNUM(slice_code);
                else QNUM(slice_start);
                else QNUM(slice_end);
                else QNUM(slice_duration);
        } /* end of while loop */

        /** do miscellaneous checking and cleanup **/
        if (nim->ndim <= 0) { /** bad! **/
                nifti_image_free(nim);
                return NULL;
        }

        nifti_datatype_sizes(nim->datatype, &(nim->nbyper), &(nim->swapsize));
        if (nim->nbyper == 0) { /** bad! **/
                nifti_image_free(nim);
                return NULL;
        }

        nim->dim[0] = nim->ndim;
        nim->dim[1] = nim->nx; nim->pixdim[1] = nim->dx;
        nim->dim[2] = nim->ny; nim->pixdim[2] = nim->dy;
        nim->dim[3] = nim->nz; nim->pixdim[3] = nim->dz;
        nim->dim[4] = nim->nt; nim->pixdim[4] = nim->dt;
        nim->dim[5] = nim->nu; nim->pixdim[5] = nim->du;
        nim->dim[6] = nim->nv; nim->pixdim[6] = nim->dv;
        nim->dim[7] = nim->nw; nim->pixdim[7] = nim->dw;

        nim->nvox =  nim->nx * nim->ny * nim->nz *
                     nim->nt * nim->nu * nim->nv * nim->nw;

        if (nim->qform_code > 0) {
                nim->qto_xyz = quatern_to_mat44(
                                 nim->quatern_b, nim->quatern_c, nim->quatern_c,
                                 nim->qoffset_x, nim->qoffset_y, nim->qoffset_z,
                                 nim->dx       , nim->dy       , nim->dz       ,
                                 nim->qfac);
        } else {
                nim->qto_xyz = quatern_to_mat44(0.0, 0.0, 0.0,
                                                0.0, 0.0, 0.0,
                                                nim->dx, nim->dy, nim->dz, 0.0);
        }

        nim->qto_ijk = mat44_inverse(nim->qto_xyz);

        if (nim->sform_code > 0)
                nim->sto_ijk = mat44_inverse(nim->sto_xyz);

        return nim;
}

static void
find_data_range(int datatype, long nvox, void *data, double range[2])
{
        int i;
        double tmp;

        range[0] = DBL_MAX;
        range[1] = -DBL_MAX;

        for (i = 0; i < nvox; i++) {
                switch (datatype) {
                case DT_INT8:
                        tmp = (double) ((char *)data)[i];
                        break;
                case DT_UINT8:
                        tmp = (double) ((unsigned char *)data)[i];
                        break;
                case DT_INT16:
                        tmp = (double) ((short *)data)[i];
                        break;
                case DT_UINT16:
                        tmp = (double) ((unsigned short *)data)[i];
                        break;
                case DT_INT32:
                        tmp = (double) ((int *)data)[i];
                        break;
                case DT_UINT32:
                        tmp = (double) ((unsigned int *)data)[i];
                        break;
                case DT_FLOAT32:
                        tmp = (double) ((float *)data)[i];
                        break;
                case DT_FLOAT64:
                        tmp = (double) ((double *)data)[i];
                        break;
                default:
                        fprintf(stderr, "Data type %d not handled\n", datatype);
                        break;
                }
                if (tmp < range[0]) {
                        range[0] = tmp;
                }
                if (tmp > range[1]) {
                        range[1] = tmp;
                }
        }
}


Status
input_nifti(char *filename, int n_dimensions, char *dim_names[],
            nc_type volume_nc_data_type, BOOLEAN volume_signed_flag,
            Real volume_voxel_min, Real volume_voxel_max,
            BOOLEAN create_volume_flag, Volume *volume,
            minc_input_options *options)
{
        Status               status = OK;

        /* NIFTI stuff */
        nifti_image *nii_ptr;

        /* MINC stuff */
        nc_type mnc_mtype;          /* MINC memory data type */
        int mnc_msign;              /* MINC !0 if signed data */
        static nc_type mnc_vtype;   /* MINC voxel data type */
        static int mnc_vsign;       /* MINC !0 if signed data */
        int mnc_ndims;              /* MINC image dimension count */
        long mnc_start[MAX_VAR_DIMS]; /* MINC data starts */
        long mnc_count[MAX_VAR_DIMS]; /* MINC data counts */
        double mnc_vrange[2];       /* MINC valid min/max */
        double mnc_srange[2];       /* MINC image min/max */
        double mnc_time_step;
        double mnc_time_start;
        int mnc_spatial_axes[MAX_NII_DIMS];
        double mnc_starts[MAX_SPACE_DIMS];
        double mnc_steps[MAX_SPACE_DIMS];
        double mnc_dircos[MAX_SPACE_DIMS][MAX_SPACE_DIMS];
        Transform mnc_xform;
        General_transform mnc_linear_xform;
        struct analyze75_hdr ana_hdr;
        static char *mnc_ordered_dim_names[MAX_SPACE_DIMS];

        /* Other stuff */
        int i, j, d;
        static int oflag = DIMORDER_XYZ;
        static int flip[MAX_SPACE_DIMS] = {0, 0, 0}; /* not used */
        void *voxels;

        mnc_vtype = NC_NAT;

        /* Read in the entire NIfTI file. */
        nii_ptr = nifti_image_read(filename, 1);

        if (nii_ptr->nifti_type == 0) { /* Analyze file!!! */
                FILE *fp;
                int ss, must_swap;

                fp = fopen(filename, "r");
                if (fp != NULL) {
                        fread(&ana_hdr, sizeof (ana_hdr), 1, fp);
                        fclose(fp);

                        must_swap = 0;
                        ss = ana_hdr.dime.dim[0];
                        if (ss != 0) {
                                if (ss < 0 || ss > 7) {
                                        swap_2(ss);
                                        if (ss < 0 || ss > 7) {
                                                /* We should never get here!! */
                                                fprintf(stderr,
                                                     "Bad dimension count!!\n");
                                        } else {
                                                must_swap = 1;
                                        }
                                }
                        } else {
                                ss = ana_hdr.hk.sizeof_hdr;
                                if (ss != sizeof(ana_hdr)) {
                                        swap_4(ss);
                                        if (ss != sizeof(ana_hdr)) {
                                                /* We should never get here!! */
                                                fprintf(stderr,
                                                        "Bad header size!!\n");
                                        } else {
                                                must_swap = 1;
                                        }
                                }
                        }

                        if (must_swap) {
                                swap_4(ana_hdr.hk.sizeof_hdr);
                                swap_4(ana_hdr.hk.extents);
                                swap_2(ana_hdr.hk.session_error);

                                swap_4(ana_hdr.dime.compressed);
                                swap_4(ana_hdr.dime.verified);
                                swap_4(ana_hdr.dime.glmax); 
                                swap_4(ana_hdr.dime.glmin);
                                swap_2bytes(8, ana_hdr.dime.dim);
                                swap_4bytes(8, ana_hdr.dime.pixdim);
                                swap_2(ana_hdr.dime.datatype);
                                swap_2(ana_hdr.dime.bitpix);
                                swap_4(ana_hdr.dime.vox_offset);
                                swap_4(ana_hdr.dime.cal_max); 
                                swap_4(ana_hdr.dime.cal_min);
                        }
                }
        }

        /* Set up the spatial axis correspondence for the call to 
         * convert_transform_to_starts_and_steps()
         */
        switch (oflag) {
        default:
        case DIMORDER_ZYX:
                mnc_ordered_dim_names[DIM_X] = MIxspace;
                mnc_ordered_dim_names[DIM_Y] = MIyspace;
                mnc_ordered_dim_names[DIM_Z] = MIzspace;
                mnc_spatial_axes[DIM_X] = DIM_X;
                mnc_spatial_axes[DIM_Y] = DIM_Y;
                mnc_spatial_axes[DIM_Z] = DIM_Z;
                break;
        case DIMORDER_ZXY:
                mnc_ordered_dim_names[DIM_X] = MIyspace;
                mnc_ordered_dim_names[DIM_Y] = MIxspace;
                mnc_ordered_dim_names[DIM_Z] = MIzspace;
                mnc_spatial_axes[DIM_X] = DIM_Y;
                mnc_spatial_axes[DIM_Y] = DIM_X;
                mnc_spatial_axes[DIM_Z] = DIM_Z;
                break;
        case DIMORDER_XYZ:
                mnc_ordered_dim_names[DIM_X] = MIzspace;
                mnc_ordered_dim_names[DIM_Y] = MIyspace;
                mnc_ordered_dim_names[DIM_Z] = MIxspace;
                mnc_spatial_axes[DIM_X] = DIM_Z;
                mnc_spatial_axes[DIM_Y] = DIM_Y;
                mnc_spatial_axes[DIM_Z] = DIM_X;
                break;
        case DIMORDER_XZY:
                mnc_ordered_dim_names[DIM_X] = MIyspace;
                mnc_ordered_dim_names[DIM_Y] = MIzspace;
                mnc_ordered_dim_names[DIM_Z] = MIxspace;
                mnc_spatial_axes[DIM_X] = DIM_Y;
                mnc_spatial_axes[DIM_Y] = DIM_Z;
                mnc_spatial_axes[DIM_Z] = DIM_X;
                break;
        case DIMORDER_YZX:
                mnc_ordered_dim_names[DIM_X] = MIxspace;
                mnc_ordered_dim_names[DIM_Y] = MIzspace;
                mnc_ordered_dim_names[DIM_Z] = MIyspace;
                mnc_spatial_axes[DIM_X] = DIM_X;
                mnc_spatial_axes[DIM_Y] = DIM_Z;
                mnc_spatial_axes[DIM_Z] = DIM_Y;
                break;
        case DIMORDER_YXZ:
                mnc_ordered_dim_names[DIM_X] = MIzspace;
                mnc_ordered_dim_names[DIM_Y] = MIxspace;
                mnc_ordered_dim_names[DIM_Z] = MIyspace;
                mnc_spatial_axes[DIM_X] = DIM_Z;
                mnc_spatial_axes[DIM_Y] = DIM_X;
                mnc_spatial_axes[DIM_Z] = DIM_Y;
                break;
        }

        switch (nii_ptr->datatype) {
        case DT_INT8:
                mnc_msign = 1;
                mnc_mtype = NC_BYTE;
                mnc_vrange[0] = CHAR_MIN;
                mnc_vrange[1] = CHAR_MAX;
                break;
        case DT_UINT8:
                mnc_msign = 0;
                mnc_mtype = NC_BYTE;
                mnc_vrange[0] = 0;
                mnc_vrange[1] = UCHAR_MAX;
                break;
        case DT_INT16:
                mnc_msign = 1;
                mnc_mtype = NC_SHORT;
                mnc_vrange[0] = SHRT_MIN;
                mnc_vrange[1] = SHRT_MAX;
                break;
        case DT_UINT16:
                mnc_msign = 0;
                mnc_mtype = NC_SHORT;
                mnc_vrange[0] = 0;
                mnc_vrange[1] = USHRT_MAX;
                break;
        case DT_INT32:
                mnc_msign = 1;
                mnc_mtype = NC_INT;
                mnc_vrange[0] = INT_MIN;
                mnc_vrange[1] = INT_MAX;
                break;
        case DT_UINT32:
                mnc_msign = 0;
                mnc_mtype = NC_INT;
                mnc_vrange[0] = 0;
                mnc_vrange[1] = UINT_MAX;
                break;
        case DT_FLOAT32:
                mnc_msign = 1;
                mnc_mtype = NC_FLOAT;
                mnc_vrange[0] = -FLT_MAX;
                mnc_vrange[1] = FLT_MAX;
                break;
        case DT_FLOAT64:
                mnc_msign = 1;
                mnc_mtype = NC_DOUBLE;
                mnc_vrange[0] = -DBL_MAX;
                mnc_vrange[1] = DBL_MAX;
                break;
        default:
                fprintf(stderr, "Data type %d not handled\n",
                                nii_ptr->datatype);
                break;
        }

        if (mnc_vtype == NC_NAT) {
                mnc_vsign = mnc_msign;
                mnc_vtype = mnc_mtype;
        }

        mnc_ndims = 0;

        if (nii_ptr->nt > 1) {
                mnc_start[mnc_ndims] = 0;
                mnc_count[mnc_ndims] = nii_ptr->nt;
                mnc_ndims++;

                switch (nii_ptr->time_units) {
                case NIFTI_UNITS_UNKNOWN:
                case NIFTI_UNITS_SEC:
                        mnc_time_step = nii_ptr->dt;
                        mnc_time_start = nii_ptr->toffset;
                        break;
                case NIFTI_UNITS_MSEC:
                        mnc_time_step = nii_ptr->dt / 1000;
                        mnc_time_start = nii_ptr->toffset / 1000;
                        break;
                case NIFTI_UNITS_USEC:
                        mnc_time_step = nii_ptr->dt / 1000000;
                        mnc_time_step = nii_ptr->dt / 1000000;
                        mnc_time_start = nii_ptr->toffset / 1000000;
                        break;
                default:
                        fprintf(stderr, "Unknown time units value %d\n",
                                        nii_ptr->time_units);
                        break;
                }
        }

        if (nii_ptr->nz > 1) {
                mnc_start[mnc_ndims] = 0;
                mnc_count[mnc_ndims] = nii_ptr->nz;
                mnc_ndims++;
        }

        if (nii_ptr->ny > 1) {
                mnc_start[mnc_ndims] = 0;
                mnc_count[mnc_ndims] = nii_ptr->ny;
                mnc_ndims++;
        }

        if (nii_ptr->nx > 1) {
                mnc_start[mnc_ndims] = 0;
                mnc_count[mnc_ndims] = nii_ptr->nx;
                mnc_ndims++;
        }

        if (nii_ptr->nu > 1) {
                mnc_start[mnc_ndims] = 0;
                mnc_count[mnc_ndims] = nii_ptr->nu;
                mnc_ndims++;
        }

        /* Calculate the starts, steps, and direction cosines. This only
         * be done properly if the file is NIfTI-1 file.  If it is an Analyze
         * file we have to resort to other methods...
         */

        if (nii_ptr->nifti_type != 0 &&
            (nii_ptr->sform_code != NIFTI_XFORM_UNKNOWN ||
             nii_ptr->qform_code != NIFTI_XFORM_UNKNOWN)) {

                make_identity_transform(&mnc_xform);

                if (nii_ptr->sform_code != NIFTI_XFORM_UNKNOWN) { /* s-form */
                        for (i = 0; i < 4; i++) {
                                for (j = 0; j < 4; j++) {
                                        Transform_elem(mnc_xform, i, j) =
                                                       nii_ptr->sto_xyz.m[i][j];
                                }
                        }
                } else { /* q-xform */
                        for (i = 0; i < 4; i++) {
                                for (j = 0; j < 4; j++) {
                                        Transform_elem(mnc_xform, i, j) =
                                                       nii_ptr->qto_xyz.m[i][j];
                                }
                        }
                }

                create_linear_transform(&mnc_linear_xform, &mnc_xform);

                convert_transform_to_starts_and_steps(&mnc_linear_xform,
                                                      MAX_SPACE_DIMS, NULL,
                                                      mnc_spatial_axes,
                                                      mnc_starts, mnc_steps,
                                                      mnc_dircos);

        } else {
                /* No official transform was found (possibly this is an Analyze
                 * file).  Just use some reasonable defaults.  */
                mnc_steps[mnc_spatial_axes[DIM_X]] = nii_ptr->dx;
                mnc_steps[mnc_spatial_axes[DIM_Y]] = nii_ptr->dy;
                mnc_steps[mnc_spatial_axes[DIM_Z]] = nii_ptr->dz;
                mnc_starts[mnc_spatial_axes[DIM_X]] = -(nii_ptr->dx *
                                                        nii_ptr->nx) / 2;
                mnc_starts[mnc_spatial_axes[DIM_Y]] = -(nii_ptr->dy *
                                                        nii_ptr->ny) / 2;
                mnc_starts[mnc_spatial_axes[DIM_Z]] = -(nii_ptr->dz *
                                                        nii_ptr->nz) / 2;

                /* Unlike the starts and steps, the direction cosines do NOT
                 * change based upon the data orientation.  */
                for (i = 0; i < MAX_SPACE_DIMS; i++) {
                        for (j = 0; j < MAX_SPACE_DIMS; j++) {
                                mnc_dircos[i][j] = (i == j) ? 1.0 : 0.0;
                        }
                }
        }

        switch (nii_ptr->xyz_units) {
        case NIFTI_UNITS_METER:
                for (i = 0; i < MAX_SPACE_DIMS; i++) {
                        mnc_starts[i] *= 1000;
                        mnc_steps[i] *= 1000;
                }
                break;
        case NIFTI_UNITS_MM:
                break;
        case NIFTI_UNITS_MICRON:
                for (i = 0; i < MAX_SPACE_DIMS; i++) {
                        mnc_starts[i] /= 1000;
                        mnc_steps[i] /= 1000;
                }
                break;
        default:
                break;
        }

        /* Find the valid minimum and maximum of the data, in order to set the
         * global image minimum and image maximum properly.
         */
        find_data_range(nii_ptr->datatype, nii_ptr->nvox, nii_ptr->data,
                        mnc_vrange);

        if (nii_ptr->scl_slope != 0.0) {
                /* Convert slope/offset to min/max */
                mnc_srange[0] = (mnc_vrange[0] * nii_ptr->scl_slope) +
                                nii_ptr->scl_inter;
                mnc_srange[1] = (mnc_vrange[1] * nii_ptr->scl_slope) +
                                nii_ptr->scl_inter;
        } else {
                mnc_srange[0] = mnc_vrange[0];
                mnc_srange[1] = mnc_vrange[1];
        }

        *volume = create_volume(n_dimensions, mnc_ordered_dim_names,
                                mnc_vtype, mnc_msign,
                                mnc_srange[0], mnc_srange[1]);

        for (d = 0; d < n_dimensions; d++) {
                (*volume)->spatial_axes[d] = mnc_spatial_axes[d];
                set_volume_direction_cosine(*volume, d, mnc_dircos[d]);
                if (flip[d]) { /* not used */
                        mnc_starts[d] = mnc_starts[d] +
                                        ((mnc_count[d] - 1) * mnc_steps[d]);
                }
        }     

        set_volume_starts(*volume, mnc_starts);
        set_voxel_to_world_transform(*volume, &mnc_linear_xform);

        set_volume_sizes(*volume, nii_ptr->dim + 1);
        alloc_volume_data(*volume);

        GET_VOXEL_PTR(voxels, *volume, 0, 0, 0, 0, 0);

        memcpy(voxels, nii_ptr->data,
               (size_t) get_volume_total_n_voxels(*volume) *
               (size_t) get_type_size(get_volume_data_type(*volume)));

        nifti_image_free(nii_ptr);

        return(status);
}

Status
input_volume_all(char *filename, int n_dimensions, char *dim_names[],
                 nc_type volume_nc_data_type, BOOLEAN volume_signed_flag,
                 Real volume_voxel_min, Real volume_voxel_max,
                 BOOLEAN create_volume_flag, Volume *volume,
                 minc_input_options *options)
{
        char *str_ptr;

        str_ptr = strrchr(filename, '.');

        if (!strcmp(str_ptr, ".nii") || !strcmp(str_ptr, ".hdr")) {
                if (input_nifti(filename, n_dimensions, dim_names,
                                volume_nc_data_type, volume_signed_flag,
                                volume_voxel_min, volume_voxel_max,
                                create_volume_flag, volume, options) != OK)
                        return(ERROR);
        } else {
                if (input_volume(filename, n_dimensions, dim_names,
                                 volume_nc_data_type, volume_signed_flag,
                                 volume_voxel_min, volume_voxel_max,
                                 create_volume_flag, volume, options) != OK)
                        return(ERROR);
        }
        return(OK);
}
